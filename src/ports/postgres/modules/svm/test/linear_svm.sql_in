/* -----------------------------------------------------------------------------
 * Test Linear Support Vector Machine
 * -------------------------------------------------------------------------- */

SELECT svm_generate_cls_data('svm_train_data', 1000, 4);
SELECT svm_generate_cls_data('svm_test_data', 1000, 4);

-- Example usage for LINEAR classification, replace the above by
SELECT svm_classification(
    'svm_train_data',
    'lclss',
    'label',
    'ind',
    NULL, -- kernel_func
    NULL, -- kernel_pararms
    NULL, --grouping_col
    'max_iter=10, tolerance=0' --optim_params
    );
-- DROP TABLE IF EXISTS svm_test_predict CASCADE;
-- SELECT svm_predict('lclss', 'svm_test_data', 'id', 'svm_test_predict');

-- checking correctness with pre-conditioning
DROP TABLE IF EXISTS svm_normalized CASCADE;
CREATE TABLE svm_normalized AS
SELECT
    id,
    array_append(array_div(array_sub(ind, ind_avg), ind_stddev), 1::FLOAT8) AS ind,
    label
FROM svm_train_data,
    (
        SELECT ARRAY[avg(ind[1]),avg(ind[2]),
            avg(ind[3]),avg(ind[4])] AS ind_avg
        FROM svm_train_data
    ) AS svm_ind_avg,
    (
        SELECT ARRAY[stddev(ind[1]),stddev(ind[2]),
            stddev(ind[3]),stddev(ind[4])] AS ind_stddev
        FROM svm_train_data
    ) AS svm_ind_stddev
ORDER BY random();

DROP TABLE IF EXISTS svm_test_normalized CASCADE;
CREATE TABLE svm_test_normalized AS
SELECT
    id,
    array_append(array_div(array_sub(ind, ind_avg), ind_stddev), 1::FLOAT8) AS ind,
    label
FROM svm_test_data,
    (
        SELECT ARRAY[avg(ind[1]),avg(ind[2]),
            avg(ind[3]),avg(ind[4])] AS ind_avg
        FROM svm_test_data
    ) AS svm_test_ind_avg,
    (
        SELECT ARRAY[stddev(ind[1]),stddev(ind[2]),
            stddev(ind[3]),stddev(ind[4])] AS ind_stddev
        FROM svm_test_data
    ) AS svm_test_ind_stddev;

----------------------------------------------------------------
-- serial
-- learning
DROP TABLE IF EXISTS svm_model CASCADE;
SELECT svm_classification(
    'svm_normalized', 
    'svm_model',
    'label',
    'ind', 
    NULL, -- kernel_func
    NULL, -- kernel_pararms
    NULL, --grouping_col
    'init_stepsize=0.03, decay_factor=1, max_iter=5, tolerance=0',
    'lambda=0',
    true -- verbose
    );
\x on
SELECT * FROM svm_model;
\x off

-- l2
DROP TABLE IF EXISTS svm_model_small_norm2 CASCADE;
SELECT svm_classification(
    'svm_normalized', 
    'svm_model_small_norm2',
    'label',
    'ind', 
    NULL, -- kernel_func
    NULL, -- kernel_pararms
    NULL, --grouping_col
    'init_stepsize=0.03, decay_factor=1, max_iter=5, tolerance=0',
    'lambda=1'
    );
\x on
SELECT * FROM svm_model_small_norm2;
\x off

SELECT
    assert(
        norm2(l2.coef) < norm2(noreg.coef),
        'l2 regularization should produce coef with smaller l2 norm!')
FROM svm_model AS noreg, svm_model_small_norm2 AS l2;


-- l1 makes sprase models
DROP TABLE IF EXISTS svm_model_very_sparse CASCADE;
SELECT svm_classification(
    'svm_normalized', 
    'svm_model_very_sparse',
    'label',
    'ind', 
    NULL, -- kernel_func
    NULL, -- kernel_pararms
    NULL, --grouping_col
    'init_stepsize=0.03, decay_factor=1, max_iter=5, tolerance=0',
    'lambda=1, norm=L1'
    );
\x on
SELECT * FROM svm_model_very_sparse;
\x off
SELECT
    assert(
        count(*) > 0,
        'The model is supposed to be sparse with reg=1')
FROM
(
    SELECT unnest(coef) AS w_i FROM svm_model_very_sparse
) subq
WHERE w_i != 0;

-- predicting
-- DROP TABLE IF EXISTS svm_test_predict CASCADE;
-- SELECT svm_predict('svm_model','svm_test_normalized', 'id', 'svm_test_predict');

-- calculating accuracy
-- the accuracy is not guaranteed to be high because the stepsize & decay_factor
-- depend on the actual number of segments
-- SELECT
--     count(*) AS misclassification_count
-- FROM svm_test_predict NATURAL JOIN svm_test_normalized
-- WHERE prediction <> label;

----------------------------------------------------------------
-- decay factor non-zero
-- learning
DROP TABLE IF EXISTS svm_model CASCADE;
SELECT svm_classification(
    'svm_normalized', 
    'svm_model',
    'label',
    'ind', 
    NULL, -- kernel_func
    NULL, -- kernel_pararms
    NULL, --grouping_col
    'init_stepsize=0.03, decay_factor=0.9, max_iter=5, tolerance=0',
    'lambda=0.001',
    true -- verbose
    );
SELECT norm_of_gradient FROM svm_model;

-- predicting
-- DROP TABLE IF EXISTS svm_test_predict CASCADE;
-- CREATE TABLE svm_test_predict AS
-- SELECT
--     svm_test_normalized.id,
--     CASE WHEN array_dot(coef, ind) >= 0 THEN 1 ELSE -1 END AS prediction,
--     label
-- FROM svm_test_normalized, svm_model;

-- -- stats for info
-- SELECT count(*) AS misclassification_count
-- FROM svm_test_predict
-- WHERE prediction <> label;